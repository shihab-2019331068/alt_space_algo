{
  "input": {
    "prefix": "i",
    "body": [
      "cin>>$0"
    ]
  },
  "Output": {
    "prefix": "o",
    "body": [{
  "input": {
    "prefix": "i",
    "body": [
      "cin>>$0"
    ]
  },
  "Output": {
    "prefix": "o",
    "body": [
      "cout<<$0"
    ]
  },
  "for loop": {
    "prefix": "f",
    "body": [
      "for($0)"
    ]
  },
  "string": {
    "prefix": "g",
    "body": [
      "string$0"
    ]
  },
  "memset": {
    "prefix": "mm",
    "body": [
      "memset($1,$2,sizeof($1));"
    ]
  },
  "next line": {
    "prefix": "nl",
    "body": [
      "<<\"\\n\""
    ]
  },
  "my if": {
    "prefix": "iff",
    "description": "",
    "body": [
      "if($0)"
    ]
  },
  "return": {
    "prefix": "r",
    "body": [
      "return"
    ]
  },
  "min": {
    "prefix": "mn",
    "body": [
      "min($0)"
    ]
  },
  "min_tree": {
    "prefix": "mtree",
    "body": [
      "ll rnq(ll l,ll r,ll u=1,ll b=1,ll e=n){",
      "   if(r<b or e<l) return inf;",
      "   if(l<=b and e<=r) return T[u];",
      "   ll m=b+e>>1;",
      "   return min(rnq(l,r,u<<1,b,m),rnq(l,r,u<<1|1,m+1,e));",
      "}",
      "",
      "void upd(ll i,ll v,ll u=1,ll b=1,ll e=n){",
      "   if(i<b or e<i) return;",
      "   if(i<=b and e<=i){T[u]+=v; return;}",
      "   ll m=b+e>>1;",
      "   upd(i,v,u<<1,b,m); upd(i,v,u<<1|1,m+1,e);",
      "   T[u]=min(T[u<<1],T[u<<1|1]);",
      "}"
    ]
  },
  "check": {
    "prefix": "chk",
    "body": [
      "ll chk(){",
      "   $0",
      "}"
    ]
  },
  "sex": {
    "prefix": "sex",
    "body": [
      "ll sex($1){",
      "   $0",
      "}"
    ]
  },
  "insert": {
    "prefix": "in",
    "body": [
      "insert($0)"
    ]
  },
  "max": {
    "prefix": "mx",
    "body": [
      "max($0)"
    ]
  },
  "setprecision": {
    "prefix": "stp",
    "body": [
      "cout<<fixed<<setprecision($1);"
    ]
  },
  "db": {
    "prefix": "d",
    "body": [
      "db($0);"
    ]
  },
  "fio": {
    "prefix": "fio",
    "body": [
      "for(i=0; i<$0; i++)"
    ]
  },
  "fjo": {
    "prefix": "fjo",
    "body": [
      "for(j=0; j<$0; j++)"
    ]
  },
  "fko": {
    "prefix": "fko",
    "body": [
      "for(k=0; k<$0; k++)"
    ]
  },
  "fin": {
    "prefix": "fin",
    "body": [
      "for(i=1; i<=$1; i++)"
    ]
  },
  "fjn": {
    "prefix": "fjn",
    "body": [
      "for(j=1; j<=$1; j++)"
    ]
  },
  "fkn": {
    "prefix": "fkn",
    "body": [
      "for(k=1; k<=$1; k++)"
    ]
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct DSU{",
      "   vll p,h;",
      "   ll com,i;",
      "   DSU(ll n){",
      "      com=n;",
      "      p=h=vll(n+3,1);",
      "      for(i=0; i<=n; i++) p[i]=i;",
      "   }",
      "   ll get(ll x){",
      "      return p[x]=p[x]==x?x:get(p[x]);",
      "   }",
      "   ll unite(ll u,ll v){",
      "      u=get(u); v=get(v);",
      "      if(u==v) return 0;",
      "      if(h[u]<h[v]) swap(u,v);",
      "      p[v]=u; h[u]+=h[v]; h[v]=0;",
      "      --com;",
      "      return 1;",
      "   }",
      "};"
    ]
  },
  "no": {
    "prefix": "no",
    "body": [
      "cout<<\"NO\\n\";"
    ]
  },
  "yesNo": {
    "prefix": "yn",
    "body": [
      "cout<<($0?\"YES\\n\":\"NO\\n\");"
    ]
  },
  "aSpace": {
    "prefix": "as",
    "body": [
      "<<\" \"<<"
    ]
  },
  "swap": {
    "prefix": "sw",
    "body": [
      "swap($0);"
    ]
  },
  "pushBack": {
    "prefix": "p",
    "body": [
      "pb($0)"
    ]
  },
  "makePair": {
    "prefix": "mp",
    "body": [
      "mp($0)"
    ]
  },
  "makeTuple": {
    "prefix": "mt",
    "body": [
      "mt($0)"
    ]
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "void dfs(ll u,ll p) {",
      "   for(ll v:g[u]) if(v!=p) {",
      "      dfs(v,u);",
      "      $0",
      "   }",
      "}"
    ]
  },
  "while": {
    "prefix": "ww",
    "body": [
      "while($0)"
    ]
  },
  "size": {
    "prefix": "z",
    "body": [
      "size()"
    ]
  },
  "tt": {
    "prefix": "tt",
    "body": [
      "ll tt; cin>>tt;",
      "while(tt--) {",
      "   $0",
      "}"
    ]
  },
  "sn": {
    "prefix": "sn",
    "body": [
      "<<\" \\n\"[i==n$0];"
    ]
  },
  "fwt": {
    "prefix": "fwt",
    "body": [
      "void upd(vll &t,ll i,ll v) {for(; i<t.size(); i+=i&-i) t[i]+=v;}",
      "ll ask(vll &t,ll i) {ll R=0; for(; i>0; i-=i&-i) R+=t[i]; return R;}"
    ]
  },
  "segTree": {
    "prefix": "stree",
    "description": "",
    "body": [
      "ll segT[N];",
      "struct SegTree {",
      "   ll mrg(ll x,ll y) {",
      "      return min(x,y);",
      "   }",
      "   ll rnq(ll l,ll r,ll u=1,ll b=1,ll e=n){",
      "      if(r<b or e<l) return inf;",
      "      if(l<=b and e<=r) return segT[u];",
      "      ll m=b+e>>1;",
      "      return mrg(rnq(l,r,u<<1,b,m),rnq(l,r,u<<1|1,m+1,e));",
      "   }",
      "   ll upd(ll i,ll v,ll u=1,ll b=1,ll e=n){",
      "      if(i<b or e<i) return;",
      "      if(i<=b and e<=i){ return segT[u]+=v;}",
      "      ll m=b+e>>1;",
      "      return mrg(upd(i,v,u<<1,b,m),upd(i,v,u<<1|1,m+1,e));",
      "   }",
      "};"
    ]
  },
  "srk2": {
    "prefix": "srk2",
    "body": [
      "void srk2(ll a[],ll n,ll b[],ll m) {",
      "   set<ll> s; map<ll,ll> ma; ll i;",
      "   for(i=1; i<=n; i++) s.insert(a[i]);",
      "   for(i=1; i<=m; i++) s.insert(b[i]);",
      "   i=0;",
      "   for(ll j:s) ma[j]=++i;",
      "   for(i=1; i<=n; i++) a[i]=ma[a[i]];",
      "   for(i=1; i<=m; i++) b[i]=ma[b[i]];",
      "}"
    ]
  },
  "continue": {
    "prefix": "con",
    "body": [
      "continue;"
    ]
  },
  "hash": {
    "prefix": "hash",
    "body": [
      "struct Hash {",
      "   ve<ve<ll>> pv;",
      "   ve<ll> b={122,123};",
      "   ",
      "   ll rabinKarpHash(const string &s,ll bi) {",
      "      ll n=s.size(),ans=0,i;",
      "      for(i=0; i<n; i++) ans=add(ans,mul(s[i],pv[bi][n-i-1]));",
      "      return ans;",
      "   }",
      "",
      "   ll roll(char c1,char c2,ll bi,ll sh,ll tz) {",
      "      sh=sub(sh,mul(c1,pv[bi][tz-1]));",
      "      sh=mul(sh,b[bi]);",
      "      sh=add(sh,c2);",
      "      return sh;",
      "   }",
      "",
      "   ll go(const string &s,const string &t) {",
      "      ll sz=s.size(),i,j,tz=t.size();",
      "      if(tz>sz) return -1;",
      "",
      "      pv=ve<ve<ll>> (2,ve<ll>(sz+7));",
      "      for(i=0; i<2; i++) for(j=1,pv[i][0]=1; j<sz+7; j++) pv[i][j]=mul(pv[i][j-1],b[i]);",
      "",
      "      ll th1=rabinKarpHash(t,0),sh1=rabinKarpHash(s.substr(0,tz),0);",
      "      ll th2=rabinKarpHash(t,1),sh2=rabinKarpHash(s.substr(0,tz),1);",
      "",
      "      if(th1==sh1 and th2==sh2) return 0;",
      "      for(i=0; i+tz<sz; i++) {",
      "         sh1=roll(s[i],s[i+tz],0,sh1,tz);",
      "         sh2=roll(s[i],s[i+tz],1,sh2,tz);",
      "         if(th1==sh1 and th2==sh2) return i+1;",
      "      }",
      "      return -1;",
      "   }",
      "};",
      ""
    ]
  },
  "Kosaraju": {
    "prefix": "ksrj",
    "body": [
      "struct Ksrj {",
      "   ve<vll> g,rg;",
      "   vll vs,sk,p;",
      "   ll n;",
      "",
      "   Ksrj(ll _n,ve<vll> &_g,ve<vll> &_rg) {",
      "      n=_n; g=_g; rg=_rg;",
      "      p=vs=vll(n+1,0); sk={};",
      "   }",
      "",
      "   void dfs(ll u,ll P,ve<vll> &g) {",
      "      vs[u]=1; p[u]=P;",
      "      for(ll v:g[u])",
      "         if(!vs[v])",
      "            dfs(v,P,g);",
      "      if(P==-1) sk.push_back(u);",
      "   }",
      "",
      "   vll go() {",
      "      ll i,u;",
      "      for(i=1; i<=n; i++)",
      "         if(!vs[i])",
      "            dfs(i,-1,g);",
      "      p=vs=vll(n+1,0);",
      "      for(; sk.size(); sk.pop_back()){",
      "         u=sk.back();",
      "         if(!vs[u])",
      "            dfs(u,u,rg);",
      "      }",
      "      return p;",
      "   }",
      "};"
    ]
  },
  "Tarjan": {
    "prefix": "tarjan",
    "body": [
      "struct Tarjan {",
      "   ll n,time;",
      "   vll sk,vs,skItm,et,lt,fat;",
      "   ve<vll> g;",
      "",
      "   Tarjan(ll _n,ve<vll> &_g) {",
      "      n=_n; g=_g;",
      "   }",
      "",
      "   void dfs(ll u) {",
      "      et[u]=lt[u]=++time;",
      "      sk.pb(u); skItm[u]=1;",
      "",
      "      for(ll v:g[u]) {",
      "         if(et[v]==-1) {",
      "            dfs(v);",
      "            lt[u]=min(lt[u],lt[v]);",
      "         } else if(skItm[v]) {",
      "            lt[u]=min(lt[u],et[v]);",
      "         }",
      "      }",
      "",
      "      if(lt[u]==et[u]) {",
      "         ll back=-1;",
      "         for(; back!=u; sk.pop_back()) {",
      "            back=sk.back();",
      "            fat[back]=u;",
      "            skItm[back]=0;",
      "         }",
      "      }",
      "   }",
      "",
      "   vll go() {",
      "      ll i;",
      "      time=0;",
      "      fat=et=lt=vll(n+1,-1);",
      "      skItm=vll(n+1,0);",
      "      for(i=0; i<=n; i++) {",
      "         if(et[i]==-1) dfs(i);",
      "      }",
      "      return fat;",
      "   }",
      "",
      "};"
    ]
  },
  "guv": {
    "prefix": "guv",
    "body": [
      "g[u].pb(v); g[v].pb(u);"
    ]
  },
  "dpf": {
    "prefix": "dpf",
    "body": [
      "ll dpf(ll i,ll k) {",
      "   ll &R=f[i][k];",
      "   if(R!=-1) return R;",
      "   $0",
      "}"
    ]
  },
  "yes": {
    "prefix": "yes",
    "body": [
      "cout<<\"YES\\n\";"
    ]
  },
  "binary search": {
    "prefix": "bs",
    "body": [
      "ll b_s(ll l,ll r){",
      "   ll m;$1",
      "   for(; l<r; ){",
      "      m=l+r>>1;",
      "      if(chk(m)) r=m;",
      "      else l=m+1;",
      "   }",
      "   return l;",
      "}"
    ]
  },
  "add": {
    "prefix": "add",
    "description": "",
    "body": [
      "ll add(ll a,ll b){return (a+b)%M;}"
    ]
  },
  "aa": {
    "prefix": "aa\r",
    "description": "",
    "body": [
      "#include<bits/stdc++.h>\r",
      "\r",
      "using namespace std;\r",
      "\r",
      "#define fastio            ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
      "#define aa                auto\r",
      "#define cn                const\r",
      "#define ll                long long\r",
      "#define ld                long double\r",
      "#define fr                first\r",
      "#define sc                second\r",
      "#define pll               pair<ll,ll>\r",
      "#define tll               tuple<ll,ll,ll>\r",
      "#define vll               vector<ll>\r",
      "#define bp(x)             __builtin_popcountll(x)\r",
      "#define all(a)            a.begin(),a.end()\r",
      "#define arr(a)            a.rbegin(),a.rend()\r",
      "#define cb(a,i)           (a>>i&1)\r",
      "#define mp(a,b)           make_pair(a,b)\r",
      "#define mt(a,b,c)         make_tuple(a,b,c)\r",
      "#define lb(a)             lower_bound(a)\r",
      "#define ub(a)             upper_bound(a)\r",
      "#define pb(a)             push_back(a)\r",
      "#define ve                vector\r",
      "\r",
      "\r",
      "#define db(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); cerr<<\"\\n\";}\r",
      "void err(istream_iterator<string> it) {}\r",
      "template<typename T, typename... Args>\r",
      "void err(istream_iterator<string> it, T a, Args... args) {\r",
      "   cerr << *it << \"=\" << a << \" ! \";\r",
      "   err(++it, args...);\r",
      "}\r",
      "\r",
      "cn ll N=5e5+7,N1=25,N2=323,inf=2e18;\r",
      "cn ld eps=1e-8;\r",
      "cn ll M=1e9+7;\r",
      "//cn ll M=998244353;\r",
      "ll a[N],b[N];\r",
      "string s;\r",
      "ll n,m,i,j,k,x,u,v;\r",
      "\r",
      "void porn(ll tt) {\r",
      "   $0\r",
      "}\r",
      "\r",
      "int main(){\r",
      "   fastio\r",
      "   ll t=1;\r",
      "   // cin>>t;\r",
      "   for(ll i=1; i<=t; i++) porn(i);\r",
      "}\r",
      ""
    ]
  },
  "mod": {
    "prefix": "mod\r",
    "description": "",
    "body": [
      "ll bmd(ll a,ll p){\r",
      "   return p?bmd(a*a%M,p>>1)*(p&1?a:1)%M:1;\r",
      "}\r",
      "ll inv(ll n){return bmd(n,M-2);}\r",
      "ll mul(ll a,ll b){return a*1ll*b%M;}\r",
      "ll add(ll a,ll b){if(a>M) a%M; if(b>M) b%M; a+=b; return a<M?a:a-M;}\r",
      "ll dvd(ll a,ll b){return mul(a,inv(b));}\r",
      "ll sub(ll a,ll b){return add(a,M-b);}"
    ]
  },
  "vd": {
    "prefix": "vd",
    "description": "",
    "body": [
      "void"
    ]
  },
  "ncr": {
    "prefix": "ncr\r",
    "description": "",
    "body": [
      "struct NCR {\r",
      "   ve<Mod> F;\r",
      "   ll N;\r",
      "   NCR(ll n) {\r",
      "      N=n; F=ve<Mod>(n+7,1);\r",
      "      for(ll i=1; i<=n; i++) F[i]=F[i-1]*i;\r",
      "   }\r",
      "   ll go(ll n,ll r) {\r",
      "      if(r>n or n>N) {\r",
      "         cout<<\"Wrong Input\\n\";\r",
      "         return -1;\r",
      "      }\r",
      "      Mod ans=F[n]/(F[r]*F[n-r]);\r",
      "      return ans.a;\r",
      "   }\r",
      "};"
    ]
  },
  "smod": {
    "prefix": "smod\r",
    "description": "",
    "body": [
      "vll F;\r",
      "struct Mod {\r",
      "   ll a;\r",
      "   Mod() {a=0;}\r",
      "   Mod(ll _a) {a=_a;}\r",
      "   \r",
      "   ll bmd(ll a,ll p){ return p?bmd(a*a%M,p>>1)*(p&1?a:1)%M:1;}\r",
      "   Mod fct(){\r",
      "      if(F.size()==0) F.pb(1);\r",
      "      for(; F.size()<=a; ) {\r",
      "         Mod x=F.back();\r",
      "         x*=F.size();\r",
      "         F.pb(x.a);\r",
      "      }\r",
      "      return F[a];\r",
      "   }\r",
      "\r",
      "   Mod operator ! () {return fct();}\r",
      "\r",
      "   Mod operator ^ (Mod p) { return Mod(bmd(a,p.a));}\r",
      "   Mod operator * (Mod p) { Mod ans(a*1ll*p.a%M); return ans;}\r",
      "   Mod operator + (Mod p) { ll b=a+p.a; return Mod(b<M?b:b-M);}\r",
      "   Mod operator - (Mod p) { ll b=a+M-p.a; return Mod(b<M?b:b-M);}\r",
      "   Mod operator / (Mod p) { ll b=bmd(p.a,M-2); return Mod(a*1ll*b%M);}\r",
      "\r",
      "   Mod operator ^= (Mod p) { return *this=(*this)^p;}\r",
      "   Mod operator *= (Mod p) { return *this=(*this)*p;}\r",
      "   Mod operator += (Mod p) { return *this=(*this)+p;}\r",
      "   Mod operator -= (Mod p) { return *this=(*this)-p;}\r",
      "   Mod operator /= (Mod p) { return *this=(*this)/p;}\r",
      "\r",
      "   Mod operator ++() {a+=1; return *this;}\r",
      "   Mod operator --() {a-=1; return *this;}\r",
      "   Mod operator ++(int) {Mod b=*this; ++(*this); return b;}\r",
      "   Mod operator --(int) {Mod b=*this; --(*this); return b;}\r",
      "\r",
      "   Mod operator = (ll p){a=p; return *this;}\r",
      "   Mod operator = (Mod p){a=p.a; return *this;}\r",
      "\r",
      "   bool operator == (Mod p) { return a==p.a;}\r",
      "   bool operator <= (Mod p) { return a<=p.a;}\r",
      "   bool operator >= (Mod p) { return a>=p.a;}\r",
      "   bool operator < (Mod p) { return a<p.a;}\r",
      "   bool operator > (Mod p) { return a>p.a;}\r",
      "   \r",
      "};\r",
      "istream& operator >> (istream& is, Mod& a) { ll b; if(is>>b) a.a=b; return is;}\r",
      "ostream& operator << (ostream& os, const Mod& a) { return os<<a.a;}"
    ]
  },
  "op": {
    "prefix": "op",
    "description": "",
    "body": [
      "operator"
    ]
  },
  "jn": {
    "prefix": "jn",
    "description": "",
    "body": [
      "cout<<\"\\n\";"
    ]
  },
  "st": {
    "prefix": "st",
    "description": "",
    "body": [
      "struct $1 {",
      "   $0",
      "};"
    ]
  },
  "so": {
    "prefix": "so",
    "description": "",
    "body": [
      "sort($0)"
    ]
  },
  "mo": {
    "prefix": "mo\r",
    "description": "",
    "body": [
      "struct Q{\r",
      "   int l,r,k,R=350;\r",
      "\r",
      "   bool operator < (Q b) {\r",
      "      if(l/R != b.l/R) return l<b.l;\r",
      "      return r<b.r;\r",
      "   }\r",
      "};"
    ]
  },
  "lazy": {
    "prefix": "lazy\r",
    "description": "",
    "body": [
      "struct Lazy {\r",
      "   vll lz,T;\r",
      "   ll outOfRange=inf,n;\r",
      "\r",
      "   Lazy(ll _n) {\r",
      "      n=_n;\r",
      "      T=lz=vll(n<<3);\r",
      "   }\r",
      "\r",
      "   void push(ll u){\r",
      "      ll u1=u<<1,u2=u1|1, v=lz[u];\r",
      "      T[u1]+=v; T[u2]+=v; lz[u1]+=v; lz[u2]+=v; lz[u]=0;\r",
      "   }\r",
      "\r",
      "   ll mrg(ll x,ll y) { return min(x,y);}\r",
      "\r",
      "   ll rnq(ll l,ll r){ return rnq(l,r,1,n,1);}\r",
      "   ll rnq(ll l,ll r,ll b,ll e,ll u){\r",
      "      push(u);\r",
      "      if(r<b or e<l) return outOfRange;\r",
      "      if(l<=b and e<=r) return T[u];\r",
      "      ll m=b+e>>1;\r",
      "      return mrg(rnq(l,r,b,m,u<<1),rnq(l,r,m+1,e,u<<1|1));\r",
      "   }\r",
      "\r",
      "   ll upd(ll l,ll r,ll v){ return upd(l,r,v,1,n,1);}\r",
      "   ll upd(ll l,ll r,ll v,ll b,ll e,ll u){\r",
      "      push(u);\r",
      "      if(r<b or e<l) return;\r",
      "      if(l<=b and e<=r){lz[u]+=v; T[u]+=v; return;}\r",
      "      ll m=b+e>>1;\r",
      "      return T[u]=mrg(upd(l,r,v,b,m,u<<1),upd(l,r,v,m+1,e,u<<1|1));\r",
      "   }\r",
      "};"
    ]
  },
  "ex": {
    "prefix": "ex",
    "description": "",
    "body": [
      "exit(0);"
    ]
  },
  "all": {
    "prefix": "all",
    "description": "",
    "body": [
      "all($0)"
    ]
  },
  "lca": {
    "prefix": "lca\r",
    "description": "",
    "body": [
      "struct LCA {\r",
      "   ve<vll> g,P;\r",
      "   vll h;\r",
      "   ll n;\r",
      "   LCA(ve<vll> &_g) {\r",
      "      ll i; g=_g;\r",
      "      n=g.size();\r",
      "      h=vll(n+1); P=ve<vll>(n+1,vll(1,-1));\r",
      "      for(i=0; i<N1; i++) dfs(1,i);\r",
      "   }\r",
      "   void dfs(ll u,ll i) {\r",
      "      if(i and h[u]>=(1ll<<i)){\r",
      "         for(; P[u].size()<=i; P[u].pb(0));\r",
      "         P[u][i]=P[P[u][i-1]][i-1];\r",
      "      }\r",
      "      for(ll v:g[u]){\r",
      "         if(P[u][0]==v) continue;\r",
      "         P[v][0]=u; h[v]=h[u]+1;\r",
      "         dfs(v,i);\r",
      "      }\r",
      "   }\r",
      "   ll go(ll l,ll r) {\r",
      "      ll R,d,i;\r",
      "      if(h[l]<h[r]) swap(l,r);\r",
      "      d=h[l]-h[r];\r",
      "      for(i=0; i<N1; i++)\r",
      "         if(cb(d,i)) l=P[l][i];\r",
      "      if(l==r) return l;\r",
      "      for(i=P[l].size()-1; i+1; i--){\r",
      "         if(P[l][i]!=P[r][i]){\r",
      "            l=P[l][i]; r=P[r][i];\r",
      "         }\r",
      "      }\r",
      "      return P[l][0];\r",
      "   }\r",
      "};"
    ]
  },
  "sum": {
    "prefix": "sum",
    "description": "",
    "body": [
      "sum+="
    ]
  },
  "pra": {
    "prefix": "pra",
    "description": "",
    "body": [
      "void pra(ll a[],ll l,ll r) {",
      "   ll i;",
      "   for(i=l; i<=r; i++) cout<<a[i]<<\" \\n\"[i==r];",
      "}"
    ]
  },
  "ch": {
    "prefix": "ch",
    "description": "",
    "body": [
      "char"
    ]
  },
  "pb": {
    "prefix": "pb",
    "description": "",
    "body": [
      "pb($0)"
    ]
  },
  "sieve": {
    "prefix": "sieve\r",
    "description": "",
    "body": [
      "bool isNotPrime[N];\r",
      "struct Sieve {\r",
      "   vll p;\r",
      "   ll n;\r",
      "   Sieve(ll _n) {\r",
      "      ll i,j; n=_n;\r",
      "      isNotPrime[0]=isNotPrime[1]=true;\r",
      "      for(i=2; i<=n; i++) if(!isNotPrime[i]) {\r",
      "         p.pb(i);\r",
      "         for(j=i*i; j<=n; j++) isNotPrime[j]=true;\r",
      "      }\r",
      "   }\r",
      "   bool isPrime(ll x) {return !isNotPrime[x];}\r",
      "\r",
      "};"
    ]
  },
  "sqit": {
    "prefix": "sqit\r",
    "description": "",
    "body": [
      "void sqit(ll l,ll r) {\r",
      "   ll i,j;\r",
      "   if(l/N2==r/N2) {\r",
      "      for(i=l; i<=r; i++);\r",
      "   } else {\r",
      "      for(i=l; i/N2==l/N2; i++);\r",
      "      for(i=l/N2+1; i<r/N2; i++);\r",
      "      for(i=r; i/N2==r/N2; i--);\r",
      "   }\r",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra\r",
    "description": "",
    "body": [
      "vll dijkstra(ll u,ll z,aa &d){\r",
      "   set<pll> s;\r",
      "   vll d(z+5,inf); d[u]=0;\r",
      "   for(s={{0,u}}; s.size(); ){\r",
      "      aa [ul,u]=*s.begin();\r",
      "      s.erase(s.begin());\r",
      "      for(aa [v,w]:g[u]){\r",
      "         if(d[v]>d[u]+w){\r",
      "            s.erase({d[v],v});\r",
      "            d[v]=d[u]+w;\r",
      "            s.insert({d[v],v});\r",
      "         }\r",
      "      }\r",
      "   }\r",
      "   return d;\r",
      "}"
    ]
  },
  "smt": {
    "prefix": "smt\r",
    "description": "",
    "body": [
      "struct SMT {\r",
      "   ll tv=0,b=inf,e=-inf,oobVal=-inf;\r",
      "   SMT *ls=0,*rs=0;\r",
      "   SMT(ll _b,ll _e): b(_b), e(_e) {};\r",
      "   SMT(ll _b,ll _e,ll _tv): b(_b), e(_e), tv(_tv) {};\r",
      "   ll mrg(ll x,ll y) {\r",
      "      return max(x,y);\r",
      "   }\r",
      "   ll rnq(ll l,ll r) {\r",
      "      if(r<b or e<l) return oobVal;\r",
      "      if(l<=b and e<=r) return tv;\r",
      "      return b<e?mrg(ls->rnq(l,r),rs->rnq(l,r)):tv;\r",
      "   }\r",
      "   ll upd(ll id,ll val) {\r",
      "      if(id<b or e<id) return tv;\r",
      "      if(id==b and e==id) { return tv+=val;}\r",
      "      if(!ls and b<e) ls=new SMT(b,b+e>>1);\r",
      "      if(!rs and b<e) rs=new SMT(b+e+2>>1,e);\r",
      "      return tv=mrg(ls->upd(id,val),rs->upd(id,val));\r",
      "   }\r",
      "};"
    ]
  },
  "lzt": {
    "prefix": "lzt\r",
    "description": "",
    "body": [
      "struct LTN {\r",
      "   ll tv=0,lv=0,b=inf,e=-inf;\r",
      "   LTN *ls,*rs;\r",
      "   LTN(ll _b,ll _e): b(_b), e(_e),\r",
      "   ls(_b<_e?new LTN(_b,_b+_e>>1):nullptr), rs(_b<_e?new LTN(_b+_e+2>>1,_e):nullptr) {}\r",
      "};\r",
      "struct LZT {\r",
      "   ll n,oobVal=0;\r",
      "   LTN *root;\r",
      "   LZT(ll _n): n(_n), root(new LTN(1,n)){}\r",
      "   ll mrg(ll x,ll y) {\r",
      "      return x+y;\r",
      "   }\r",
      "   void push(LTN *u) {\r",
      "      u->tv+=(u->lv)*((u->e)-(u->b)+1);\r",
      "      if(u->b<u->e) {\r",
      "         u->ls->lv+=u->lv;\r",
      "         u->rs->lv+=u->lv;\r",
      "      }\r",
      "      u->lv=0;\r",
      "   }\r",
      "   ll rnq(ll l,ll r) {return rnq(l,r,root);}\r",
      "   ll rnq(ll l,ll r,LTN *u) {\r",
      "      push(u);\r",
      "      if(r<u->b or u->e<l) return oobVal;\r",
      "      if(l<=u->b and u->e<=r) return u->tv;\r",
      "      return mrg(rnq(l,r,u->ls),rnq(l,r,u->rs));\r",
      "   }\r",
      "   ll upd(ll l,ll r,ll val){return upd(l,r,val,root);}\r",
      "   ll upd(ll l,ll r,ll val,LTN *u) {\r",
      "      push(u);\r",
      "      if(r<u->b or u->e<l) return u->tv;\r",
      "      if(l<=u->b and u->e<=r) { u->lv+=val; push(u); return u->tv;}\r",
      "      return u->tv=mrg(upd(l,r,val,u->ls),upd(l,r,val,u->rs));\r",
      "   }\r",
      "};"
    ]
  },
  "lct": {
    "prefix": "lct\r",
    "description": "",
    "body": [
      "\r",
      "\r",
      "struct Line {\r",
      "   ll m,b;\r",
      "   ll operator()(ll x){return m*x+b;}\r",
      "};\r",
      "struct LCNode {\r",
      "   // val is the line that\r",
      "   // has the minimum y for\r",
      "   // x=m=l+r>>1\r",
      "   Line val;\r",
      "   LCNode *ls=0,*rs=0;\r",
      "   LCNode(Line _val): val(_val){}\r",
      "\r",
      "   void upd(ll l,ll r,Line val) {\r",
      "      if(l+1==r) {\r",
      "         if(val(l)<this->val(l)) this->val=val;\r",
      "         return;\r",
      "      }\r",
      "      ll m=l+r>>1;\r",
      "      // slope of val is bigger\r",
      "      // so that the crossing point is left of 'm'\r",
      "      if(val.m<this->val.m) swap(val,this->val);\r",
      "      if(val(m)<this->val(m)) {\r",
      "         swap(val,this->val);\r",
      "         if(this->rs) this->rs->upd(m,r,val);\r",
      "         else this->rs=new LCNode(val);\r",
      "      } else {\r",
      "         if(this->ls) this->ls->upd(l,m,val);\r",
      "         else this->ls=new LCNode(val);\r",
      "      }\r",
      "      return;\r",
      "   }\r",
      "   ll rnq(ll l,ll r,ll x) {\r",
      "      if(l+1==r) return this->val(x);\r",
      "      ll m=l+r>>1;\r",
      "      if(x<m and (this->ls)) return min(this->val(x),this->ls->rnq(l,m,x));\r",
      "      if(this->rs) return min(this->val(x),this->rs->rnq(m,r,x));\r",
      "      return this->val(x);\r",
      "   }\r",
      "};"
    ]
  },
  "bbb": {
    "prefix": "bbb\r",
    "description": "",
    "body": [
      "string bbb(ll x) {\r",
      "   string s;\r",
      "   bool ok=0;\r",
      "   for(ll i=63; i>=0; i--) {\r",
      "      ok|=(x>>i)&1;\r",
      "      if(ok) s+=((x>>i)&1)?\"1\":\"0\";\r",
      "   }\r",
      "   return s;\r",
      "}"
    ]
  },
  "sos": {
    "prefix": "sos\r",
    "description": "",
    "body": [
      "\r",
      "vll sos(vll &v) {\r",
      "   ll n=v.size(), nn=(ll)log2(n)+1, i;\r",
      "   vll sum(1ll<<nn,0);\r",
      "   for(i=0; i<n; i++) sum[i]=v[i];\r",
      "   for(i=0; i<nn; i++) for(ll msk=0; msk<(1ll<<nn); msk++) {\r",
      "      if((msk>>i)&1) sum[msk]+=sum[msk^(1ll<<i)];\r",
      "   }\r",
      "   return sum;\r",
      "}"
    ]
  }
}
      "cout<<$0"
    ]
  },
  "for loop": {
    "prefix": "f",
    "body": [
      "for($0)"
    ]
  },
  "string": {
    "prefix": "g",
    "body": [
      "string$0"
    ]
  },
  "memset": {
    "prefix": "mm",
    "body": [
      "memset($1,$2,sizeof($1));"
    ]
  },
  "next line": {
    "prefix": "nl",
    "body": [
      "<<\"\\n\""
    ]
  },
  "my if": {
    "prefix": "iff",
    "description": "",
    "body": [
      "if($0)"
    ]
  },
  "return": {
    "prefix": "r",
    "body": [
      "return"
    ]
  },
  "min": {
    "prefix": "mn",
    "body": [
      "min($0)"
    ]
  },
  "min_tree": {
    "prefix": "mtree",
    "body": [
      "ll rnq(ll l,ll r,ll u=1,ll b=1,ll e=n){",
      "   if(r<b or e<l) return inf;",
      "   if(l<=b and e<=r) return T[u];",
      "   ll m=b+e>>1;",
      "   return min(rnq(l,r,u<<1,b,m),rnq(l,r,u<<1|1,m+1,e));",
      "}",
      "",
      "void upd(ll i,ll v,ll u=1,ll b=1,ll e=n){",
      "   if(i<b or e<i) return;",
      "   if(i<=b and e<=i){T[u]+=v; return;}",
      "   ll m=b+e>>1;",
      "   upd(i,v,u<<1,b,m); upd(i,v,u<<1|1,m+1,e);",
      "   T[u]=min(T[u<<1],T[u<<1|1]);",
      "}"
    ]
  },
  "check": {
    "prefix": "chk",
    "body": [
      "ll chk(){",
      "   $0",
      "}"
    ]
  },
  "sex": {
    "prefix": "sex",
    "body": [
      "ll sex($1){",
      "   $0",
      "}"
    ]
  },
  "insert": {
    "prefix": "in",
    "body": [
      "insert($0)"
    ]
  },
  "max": {
    "prefix": "mx",
    "body": [
      "max($0)"
    ]
  },
  "setprecision": {
    "prefix": "stp",
    "body": [
      "cout<<fixed<<setprecision($1);"
    ]
  },
  "db": {
    "prefix": "d",
    "body": [
      "db($0);"
    ]
  },
  "fio": {
    "prefix": "fio",
    "body": [
      "for(i=0; i<$0; i++)"
    ]
  },
  "fjo": {
    "prefix": "fjo",
    "body": [
      "for(j=0; j<$0; j++)"
    ]
  },
  "fko": {
    "prefix": "fko",
    "body": [
      "for(k=0; k<$0; k++)"
    ]
  },
  "fin": {
    "prefix": "fin",
    "body": [
      "for(i=1; i<=$1; i++)"
    ]
  },
  "fjn": {
    "prefix": "fjn",
    "body": [
      "for(j=1; j<=$1; j++)"
    ]
  },
  "fkn": {
    "prefix": "fkn",
    "body": [
      "for(k=1; k<=$1; k++)"
    ]
  },
  "dsu": {
    "prefix": "dsu",
    "body": [
      "struct DSU{",
      "   vll p,h;",
      "   ll com,i;",
      "   DSU(ll n){",
      "      com=n;",
      "      p=h=vll(n+3,1);",
      "      for(i=0; i<=n; i++) p[i]=i;",
      "   }",
      "   ll get(ll x){",
      "      return p[x]=p[x]==x?x:get(p[x]);",
      "   }",
      "   ll unite(ll u,ll v){",
      "      u=get(u); v=get(v);",
      "      if(u==v) return 0;",
      "      if(h[u]<h[v]) swap(u,v);",
      "      p[v]=u; h[u]+=h[v]; h[v]=0;",
      "      --com;",
      "      return 1;",
      "   }",
      "};"
    ]
  },
  "no": {
    "prefix": "no",
    "body": [
      "cout<<\"NO\\n\";"
    ]
  },
  "yesNo": {
    "prefix": "yn",
    "body": [
      "cout<<($0?\"YES\\n\":\"NO\\n\");"
    ]
  },
  "aSpace": {
    "prefix": "as",
    "body": [
      "<<\" \"<<"
    ]
  },
  "swap": {
    "prefix": "sw",
    "body": [
      "swap($0);"
    ]
  },
  "pushBack": {
    "prefix": "p",
    "body": [
      "pb($0)"
    ]
  },
  "makePair": {
    "prefix": "mp",
    "body": [
      "mp($0)"
    ]
  },
  "makeTuple": {
    "prefix": "mt",
    "body": [
      "mt($0)"
    ]
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "void dfs(ll u,ll p) {",
      "   for(ll v:g[u]) if(v!=p) {",
      "      dfs(v,u);",
      "      $0",
      "   }",
      "}"
    ]
  },
  "while": {
    "prefix": "ww",
    "body": [
      "while($0)"
    ]
  },
  "size": {
    "prefix": "z",
    "body": [
      "size()"
    ]
  },
  "tt": {
    "prefix": "tt",
    "body": [
      "ll tt; cin>>tt;",
      "while(tt--) {",
      "   $0",
      "}"
    ]
  },
  "sn": {
    "prefix": "sn",
    "body": [
      "<<\" \\n\"[i==n$0];"
    ]
  },
  "fwt": {
    "prefix": "fwt",
    "body": [
      "void upd(vll &t,ll i,ll v) {for(; i<t.size(); i+=i&-i) t[i]+=v;}",
      "ll ask(vll &t,ll i) {ll R=0; for(; i>0; i-=i&-i) R+=t[i]; return R;}"
    ]
  },
  "segTree": {
    "prefix": "stree",
    "description": "",
    "body": [
      "ll segT[N];",
      "struct SegTree {",
      "   ll mrg(ll x,ll y) {",
      "      return min(x,y);",
      "   }",
      "   ll rnq(ll l,ll r,ll u=1,ll b=1,ll e=n){",
      "      if(r<b or e<l) return inf;",
      "      if(l<=b and e<=r) return segT[u];",
      "      ll m=b+e>>1;",
      "      return mrg(rnq(l,r,u<<1,b,m),rnq(l,r,u<<1|1,m+1,e));",
      "   }",
      "   ll upd(ll i,ll v,ll u=1,ll b=1,ll e=n){",
      "      if(i<b or e<i) return;",
      "      if(i<=b and e<=i){ return segT[u]+=v;}",
      "      ll m=b+e>>1;",
      "      return mrg(upd(i,v,u<<1,b,m),upd(i,v,u<<1|1,m+1,e));",
      "   }",
      "};"
    ]
  },
  "srk2": {
    "prefix": "srk2",
    "body": [
      "void srk2(ll a[],ll n,ll b[],ll m) {",
      "   set<ll> s; map<ll,ll> ma; ll i;",
      "   for(i=1; i<=n; i++) s.insert(a[i]);",
      "   for(i=1; i<=m; i++) s.insert(b[i]);",
      "   i=0;",
      "   for(ll j:s) ma[j]=++i;",
      "   for(i=1; i<=n; i++) a[i]=ma[a[i]];",
      "   for(i=1; i<=m; i++) b[i]=ma[b[i]];",
      "}"
    ]
  },
  "continue": {
    "prefix": "con",
    "body": [
      "continue;"
    ]
  },
  "hash": {
    "prefix": "hash",
    "body": [
      "struct Hash {",
      "   ve<ve<ll>> pv;",
      "   ve<ll> b={122,123};",
      "   ",
      "   ll rabinKarpHash(const string &s,ll bi) {",
      "      ll n=s.size(),ans=0,i;",
      "      for(i=0; i<n; i++) ans=add(ans,mul(s[i],pv[bi][n-i-1]));",
      "      return ans;",
      "   }",
      "",
      "   ll roll(char c1,char c2,ll bi,ll sh,ll tz) {",
      "      sh=sub(sh,mul(c1,pv[bi][tz-1]));",
      "      sh=mul(sh,b[bi]);",
      "      sh=add(sh,c2);",
      "      return sh;",
      "   }",
      "",
      "   ll go(const string &s,const string &t) {",
      "      ll sz=s.size(),i,j,tz=t.size();",
      "      if(tz>sz) return -1;",
      "",
      "      pv=ve<ve<ll>> (2,ve<ll>(sz+7));",
      "      for(i=0; i<2; i++) for(j=1,pv[i][0]=1; j<sz+7; j++) pv[i][j]=mul(pv[i][j-1],b[i]);",
      "",
      "      ll th1=rabinKarpHash(t,0),sh1=rabinKarpHash(s.substr(0,tz),0);",
      "      ll th2=rabinKarpHash(t,1),sh2=rabinKarpHash(s.substr(0,tz),1);",
      "",
      "      if(th1==sh1 and th2==sh2) return 0;",
      "      for(i=0; i+tz<sz; i++) {",
      "         sh1=roll(s[i],s[i+tz],0,sh1,tz);",
      "         sh2=roll(s[i],s[i+tz],1,sh2,tz);",
      "         if(th1==sh1 and th2==sh2) return i+1;",
      "      }",
      "      return -1;",
      "   }",
      "};",
      ""
    ]
  },
  "Kosaraju": {
    "prefix": "ksrj",
    "body": [
      "struct Ksrj {",
      "   ve<vll> g,rg;",
      "   vll vs,sk,p;",
      "   ll n;",
      "",
      "   Ksrj(ll _n,ve<vll> &_g,ve<vll> &_rg) {",
      "      n=_n; g=_g; rg=_rg;",
      "      p=vs=vll(n+1,0); sk={};",
      "   }",
      "",
      "   void dfs(ll u,ll P,ve<vll> &g) {",
      "      vs[u]=1; p[u]=P;",
      "      for(ll v:g[u])",
      "         if(!vs[v])",
      "            dfs(v,P,g);",
      "      if(P==-1) sk.push_back(u);",
      "   }",
      "",
      "   vll go() {",
      "      ll i,u;",
      "      for(i=1; i<=n; i++)",
      "         if(!vs[i])",
      "            dfs(i,-1,g);",
      "      p=vs=vll(n+1,0);",
      "      for(; sk.size(); sk.pop_back()){",
      "         u=sk.back();",
      "         if(!vs[u])",
      "            dfs(u,u,rg);",
      "      }",
      "      return p;",
      "   }",
      "};"
    ]
  },
  "Tarjan": {
    "prefix": "tarjan",
    "body": [
      "struct Tarjan {",
      "   ll n,time;",
      "   vll sk,vs,skItm,et,lt,fat;",
      "   ve<vll> g;",
      "",
      "   Tarjan(ll _n,ve<vll> &_g) {",
      "      n=_n; g=_g;",
      "   }",
      "",
      "   void dfs(ll u) {",
      "      et[u]=lt[u]=++time;",
      "      sk.pb(u); skItm[u]=1;",
      "",
      "      for(ll v:g[u]) {",
      "         if(et[v]==-1) {",
      "            dfs(v);",
      "            lt[u]=min(lt[u],lt[v]);",
      "         } else if(skItm[v]) {",
      "            lt[u]=min(lt[u],et[v]);",
      "         }",
      "      }",
      "",
      "      if(lt[u]==et[u]) {",
      "         ll back=-1;",
      "         for(; back!=u; sk.pop_back()) {",
      "            back=sk.back();",
      "            fat[back]=u;",
      "            skItm[back]=0;",
      "         }",
      "      }",
      "   }",
      "",
      "   vll go() {",
      "      ll i;",
      "      time=0;",
      "      fat=et=lt=vll(n+1,-1);",
      "      skItm=vll(n+1,0);",
      "      for(i=0; i<=n; i++) {",
      "         if(et[i]==-1) dfs(i);",
      "      }",
      "      return fat;",
      "   }",
      "",
      "};"
    ]
  },
  "guv": {
    "prefix": "guv",
    "body": [
      "g[u].pb(v); g[v].pb(u);"
    ]
  },
  "dpf": {
    "prefix": "dpf",
    "body": [
      "ll dpf(ll i,ll k) {",
      "   ll &R=f[i][k];",
      "   if(R!=-1) return R;",
      "   $0",
      "}"
    ]
  },
  "yes": {
    "prefix": "yes",
    "body": [
      "cout<<\"YES\\n\";"
    ]
  },
  "binary search": {
    "prefix": "bs",
    "body": [
      "ll b_s(ll l,ll r){",
      "   ll m;$1",
      "   for(; l<r; ){",
      "      m=l+r>>1;",
      "      if(chk(m)) r=m;",
      "      else l=m+1;",
      "   }",
      "   return l;",
      "}"
    ]
  },
  "add": {
    "prefix": "add",
    "description": "",
    "body": [
      "ll add(ll a,ll b){return (a+b)%M;}"
    ]
  },
  "aa": {
    "prefix": "aa\r",
    "description": "",
    "body": [
      "#include<bits/stdc++.h>\r",
      "\r",
      "using namespace std;\r",
      "\r",
      "#define fastio            ios_base::sync_with_stdio(false); cin.tie(NULL);\r",
      "#define aa                auto\r",
      "#define cn                const\r",
      "#define ll                long long\r",
      "#define ld                long double\r",
      "#define fr                first\r",
      "#define sc                second\r",
      "#define pll               pair<ll,ll>\r",
      "#define tll               tuple<ll,ll,ll>\r",
      "#define vll               vector<ll>\r",
      "#define bp(x)             __builtin_popcountll(x)\r",
      "#define all(a)            a.begin(),a.end()\r",
      "#define arr(a)            a.rbegin(),a.rend()\r",
      "#define cb(a,i)           (a>>i&1)\r",
      "#define mp(a,b)           make_pair(a,b)\r",
      "#define mt(a,b,c)         make_tuple(a,b,c)\r",
      "#define lb(a)             lower_bound(a)\r",
      "#define ub(a)             upper_bound(a)\r",
      "#define pb(a)             push_back(a)\r",
      "#define ve                vector\r",
      "\r",
      "\r",
      "#define db(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); cerr<<\"\\n\";}\r",
      "void err(istream_iterator<string> it) {}\r",
      "template<typename T, typename... Args>\r",
      "void err(istream_iterator<string> it, T a, Args... args) {\r",
      "   cerr << *it << \"=\" << a << \" ! \";\r",
      "   err(++it, args...);\r",
      "}\r",
      "\r",
      "cn ll N=5e5+7,N1=25,N2=323,inf=2e18;\r",
      "cn ld eps=1e-8;\r",
      "cn ll M=1e9+7;\r",
      "//cn ll M=998244353;\r",
      "ll a[N],b[N];\r",
      "string s;\r",
      "ll n,m,i,j,k,x,u,v;\r",
      "\r",
      "void porn(ll tt) {\r",
      "   $0\r",
      "}\r",
      "\r",
      "int main(){\r",
      "   fastio\r",
      "   ll t=1;\r",
      "   // cin>>t;\r",
      "   for(ll i=1; i<=t; i++) porn(i);\r",
      "}\r",
      ""
    ]
  },
  "mod": {
    "prefix": "mod\r",
    "description": "",
    "body": [
      "ll bmd(ll a,ll p){\r",
      "   return p?bmd(a*a%M,p>>1)*(p&1?a:1)%M:1;\r",
      "}\r",
      "ll inv(ll n){return bmd(n,M-2);}\r",
      "ll mul(ll a,ll b){return a*1ll*b%M;}\r",
      "ll add(ll a,ll b){if(a>M) a%M; if(b>M) b%M; a+=b; return a<M?a:a-M;}\r",
      "ll dvd(ll a,ll b){return mul(a,inv(b));}\r",
      "ll sub(ll a,ll b){return add(a,M-b);}"
    ]
  },
  "vd": {
    "prefix": "vd",
    "description": "",
    "body": [
      "void"
    ]
  },
  "ncr": {
    "prefix": "ncr\r",
    "description": "",
    "body": [
      "struct NCR {\r",
      "   ve<Mod> F;\r",
      "   ll N;\r",
      "   NCR(ll n) {\r",
      "      N=n; F=ve<Mod>(n+7,1);\r",
      "      for(ll i=1; i<=n; i++) F[i]=F[i-1]*i;\r",
      "   }\r",
      "   ll go(ll n,ll r) {\r",
      "      if(r>n or n>N) {\r",
      "         cout<<\"Wrong Input\\n\";\r",
      "         return -1;\r",
      "      }\r",
      "      Mod ans=F[n]/(F[r]*F[n-r]);\r",
      "      return ans.a;\r",
      "   }\r",
      "};"
    ]
  },
  "smod": {
    "prefix": "smod\r",
    "description": "",
    "body": [
      "vll F;\r",
      "struct Mod {\r",
      "   ll a;\r",
      "   Mod() {a=0;}\r",
      "   Mod(ll _a) {a=_a;}\r",
      "   \r",
      "   ll bmd(ll a,ll p){ return p?bmd(a*a%M,p>>1)*(p&1?a:1)%M:1;}\r",
      "   Mod fct(){\r",
      "      if(F.size()==0) F.pb(1);\r",
      "      for(; F.size()<=a; ) {\r",
      "         Mod x=F.back();\r",
      "         x*=F.size();\r",
      "         F.pb(x.a);\r",
      "      }\r",
      "      return F[a];\r",
      "   }\r",
      "\r",
      "   Mod operator ! () {return fct();}\r",
      "\r",
      "   Mod operator ^ (Mod p) { return Mod(bmd(a,p.a));}\r",
      "   Mod operator * (Mod p) { Mod ans(a*1ll*p.a%M); return ans;}\r",
      "   Mod operator + (Mod p) { ll b=a+p.a; return Mod(b<M?b:b-M);}\r",
      "   Mod operator - (Mod p) { ll b=a+M-p.a; return Mod(b<M?b:b-M);}\r",
      "   Mod operator / (Mod p) { ll b=bmd(p.a,M-2); return Mod(a*1ll*b%M);}\r",
      "\r",
      "   Mod operator ^= (Mod p) { return *this=(*this)^p;}\r",
      "   Mod operator *= (Mod p) { return *this=(*this)*p;}\r",
      "   Mod operator += (Mod p) { return *this=(*this)+p;}\r",
      "   Mod operator -= (Mod p) { return *this=(*this)-p;}\r",
      "   Mod operator /= (Mod p) { return *this=(*this)/p;}\r",
      "\r",
      "   Mod operator ++() {a+=1; return *this;}\r",
      "   Mod operator --() {a-=1; return *this;}\r",
      "   Mod operator ++(int) {Mod b=*this; ++(*this); return b;}\r",
      "   Mod operator --(int) {Mod b=*this; --(*this); return b;}\r",
      "\r",
      "   Mod operator = (ll p){a=p; return *this;}\r",
      "   Mod operator = (Mod p){a=p.a; return *this;}\r",
      "\r",
      "   bool operator == (Mod p) { return a==p.a;}\r",
      "   bool operator <= (Mod p) { return a<=p.a;}\r",
      "   bool operator >= (Mod p) { return a>=p.a;}\r",
      "   bool operator < (Mod p) { return a<p.a;}\r",
      "   bool operator > (Mod p) { return a>p.a;}\r",
      "   \r",
      "};\r",
      "istream& operator >> (istream& is, Mod& a) { ll b; if(is>>b) a.a=b; return is;}\r",
      "ostream& operator << (ostream& os, const Mod& a) { return os<<a.a;}"
    ]
  },
  "op": {
    "prefix": "op",
    "description": "",
    "body": [
      "operator"
    ]
  },
  "jn": {
    "prefix": "jn",
    "description": "",
    "body": [
      "cout<<\"\\n\";"
    ]
  },
  "st": {
    "prefix": "st",
    "description": "",
    "body": [
      "struct $1 {",
      "   $0",
      "};"
    ]
  },
  "so": {
    "prefix": "so",
    "description": "",
    "body": [
      "sort($0)"
    ]
  },
  "mo": {
    "prefix": "mo\r",
    "description": "",
    "body": [
      "struct Q{\r",
      "   int l,r,k,R=350;\r",
      "\r",
      "   bool operator < (Q b) {\r",
      "      if(l/R != b.l/R) return l<b.l;\r",
      "      return r<b.r;\r",
      "   }\r",
      "};"
    ]
  },
  "lazy": {
    "prefix": "lazy\r",
    "description": "",
    "body": [
      "struct Lazy {\r",
      "   vll lz,T;\r",
      "   ll outOfRange=inf,n;\r",
      "\r",
      "   Lazy(ll _n) {\r",
      "      n=_n;\r",
      "      T=lz=vll(n<<3);\r",
      "   }\r",
      "\r",
      "   void push(ll u){\r",
      "      ll u1=u<<1,u2=u1|1, v=lz[u];\r",
      "      T[u1]+=v; T[u2]+=v; lz[u1]+=v; lz[u2]+=v; lz[u]=0;\r",
      "   }\r",
      "\r",
      "   ll mrg(ll x,ll y) { return min(x,y);}\r",
      "\r",
      "   ll rnq(ll l,ll r){ return rnq(l,r,1,n,1);}\r",
      "   ll rnq(ll l,ll r,ll b,ll e,ll u){\r",
      "      push(u);\r",
      "      if(r<b or e<l) return outOfRange;\r",
      "      if(l<=b and e<=r) return T[u];\r",
      "      ll m=b+e>>1;\r",
      "      return mrg(rnq(l,r,b,m,u<<1),rnq(l,r,m+1,e,u<<1|1));\r",
      "   }\r",
      "\r",
      "   ll upd(ll l,ll r,ll v){ return upd(l,r,v,1,n,1);}\r",
      "   ll upd(ll l,ll r,ll v,ll b,ll e,ll u){\r",
      "      push(u);\r",
      "      if(r<b or e<l) return;\r",
      "      if(l<=b and e<=r){lz[u]+=v; T[u]+=v; return;}\r",
      "      ll m=b+e>>1;\r",
      "      return T[u]=mrg(upd(l,r,v,b,m,u<<1),upd(l,r,v,m+1,e,u<<1|1));\r",
      "   }\r",
      "};"
    ]
  },
  "ex": {
    "prefix": "ex",
    "description": "",
    "body": [
      "exit(0);"
    ]
  },
  "all": {
    "prefix": "all",
    "description": "",
    "body": [
      "all($0)"
    ]
  },
  "lca": {
    "prefix": "lca\r",
    "description": "",
    "body": [
      "struct LCA {\r",
      "   ve<vll> g,P;\r",
      "   vll h;\r",
      "   ll n;\r",
      "   LCA(ve<vll> &_g) {\r",
      "      ll i; g=_g;\r",
      "      n=g.size();\r",
      "      h=vll(n+1); P=ve<vll>(n+1,vll(1,-1));\r",
      "      for(i=0; i<N1; i++) dfs(1,i);\r",
      "   }\r",
      "   void dfs(ll u,ll i) {\r",
      "      if(i and h[u]>=(1ll<<i)){\r",
      "         for(; P[u].size()<=i; P[u].pb(0));\r",
      "         P[u][i]=P[P[u][i-1]][i-1];\r",
      "      }\r",
      "      for(ll v:g[u]){\r",
      "         if(P[u][0]==v) continue;\r",
      "         P[v][0]=u; h[v]=h[u]+1;\r",
      "         dfs(v,i);\r",
      "      }\r",
      "   }\r",
      "   ll go(ll l,ll r) {\r",
      "      ll R,d,i;\r",
      "      if(h[l]<h[r]) swap(l,r);\r",
      "      d=h[l]-h[r];\r",
      "      for(i=0; i<N1; i++)\r",
      "         if(cb(d,i)) l=P[l][i];\r",
      "      if(l==r) return l;\r",
      "      for(i=P[l].size()-1; i+1; i--){\r",
      "         if(P[l][i]!=P[r][i]){\r",
      "            l=P[l][i]; r=P[r][i];\r",
      "         }\r",
      "      }\r",
      "      return P[l][0];\r",
      "   }\r",
      "};"
    ]
  },
  "sum": {
    "prefix": "sum",
    "description": "",
    "body": [
      "sum+="
    ]
  },
  "pra": {
    "prefix": "pra",
    "description": "",
    "body": [
      "void pra(ll a[],ll l,ll r) {",
      "   ll i;",
      "   for(i=l; i<=r; i++) cout<<a[i]<<\" \\n\"[i==r];",
      "}"
    ]
  },
  "ch": {
    "prefix": "ch",
    "description": "",
    "body": [
      "char"
    ]
  },
  "pb": {
    "prefix": "pb",
    "description": "",
    "body": [
      "pb($0)"
    ]
  },
  "sieve": {
    "prefix": "sieve\r",
    "description": "",
    "body": [
      "bool isNotPrime[N];\r",
      "struct Sieve {\r",
      "   vll p;\r",
      "   ll n;\r",
      "   Sieve(ll _n) {\r",
      "      ll i,j; n=_n;\r",
      "      isNotPrime[0]=isNotPrime[1]=true;\r",
      "      for(i=2; i<=n; i++) if(!isNotPrime[i]) {\r",
      "         p.pb(i);\r",
      "         for(j=i*i; j<=n; j++) isNotPrime[j]=true;\r",
      "      }\r",
      "   }\r",
      "   bool isPrime(ll x) {return !isNotPrime[x];}\r",
      "\r",
      "};"
    ]
  },
  "sqit": {
    "prefix": "sqit\r",
    "description": "",
    "body": [
      "void sqit(ll l,ll r) {\r",
      "   ll i,j;\r",
      "   if(l/N2==r/N2) {\r",
      "      for(i=l; i<=r; i++);\r",
      "   } else {\r",
      "      for(i=l; i/N2==l/N2; i++);\r",
      "      for(i=l/N2+1; i<r/N2; i++);\r",
      "      for(i=r; i/N2==r/N2; i--);\r",
      "   }\r",
      "}"
    ]
  },
  "dijkstra": {
    "prefix": "dijkstra\r",
    "description": "",
    "body": [
      "vll dijkstra(ll u,ll z,aa &d){\r",
      "   set<pll> s;\r",
      "   vll d(z+5,inf); d[u]=0;\r",
      "   for(s={{0,u}}; s.size(); ){\r",
      "      aa [ul,u]=*s.begin();\r",
      "      s.erase(s.begin());\r",
      "      for(aa [v,w]:g[u]){\r",
      "         if(d[v]>d[u]+w){\r",
      "            s.erase({d[v],v});\r",
      "            d[v]=d[u]+w;\r",
      "            s.insert({d[v],v});\r",
      "         }\r",
      "      }\r",
      "   }\r",
      "   return d;\r",
      "}"
    ]
  },
  "smt": {
    "prefix": "smt\r",
    "description": "",
    "body": [
      "struct Stn {\r",
      "   ll tv=0,b=inf,e=-inf;\r",
      "   Stn *ls,*rs;\r",
      "   Stn(){}\r",
      "   Stn(ll _b,ll _e) {\r",
      "      b=_b; e=_e;\r",
      "      if(b<e) {\r",
      "         ll m=b+e>>1;\r",
      "         ls=new Stn(b,m);\r",
      "         rs=new Stn(m+1,e);\r",
      "      }\r",
      "   }\r",
      "};\r",
      "struct SMT {\r",
      "   ll n,oobVal=0;\r",
      "   Stn *root;\r",
      "   SMT(ll _n) {\r",
      "      n=_n;\r",
      "      root=new Stn(1,n);\r",
      "   }\r",
      "   ll mrg(ll x,ll y) {\r",
      "      return x+y;\r",
      "   }\r",
      "   ll rnq(ll l,ll r) {return rnq(l,r,root);}\r",
      "   ll rnq(ll l,ll r,Stn *u) {\r",
      "      if(r<u->b or u->e<l) return oobVal;\r",
      "      if(l<=u->b and u->e<=r) return u->tv;\r",
      "      return mrg(rnq(l,r,u->ls),rnq(l,r,u->rs));\r",
      "   }\r",
      "   ll upd(ll id,ll val){return upd(id,val,root);}\r",
      "   ll upd(ll id,ll val,Stn *u) {\r",
      "      ll b=u->b, e=u->e;\r",
      "      if(id<b or e<id) return u->tv;\r",
      "      if(id==b and e==id) { return u->tv+=val;}\r",
      "      return u->tv=mrg(upd(id,val,u->ls),upd(id,val,u->rs));\r",
      "   }\r",
      "};"
    ]
  },
  "lzt": {
    "prefix": "lzt\r",
    "description": "",
    "body": [
      "struct LTN {\r",
      "   ll tv=0,lv=0,b=inf,e=-inf;\r",
      "   LTN *ls,*rs;\r",
      "   LTN(ll _b,ll _e): b(_b), e(_e),\r",
      "   ls(_b<_e?new LTN(_b,_b+_e>>1):nullptr), rs(_b<_e?new LTN(_b+_e+2>>1,_e):nullptr) {}\r",
      "};\r",
      "struct LZT {\r",
      "   ll n,oobVal=0;\r",
      "   LTN *root;\r",
      "   LZT(ll _n): n(_n), root(new LTN(1,n)){}\r",
      "   ll mrg(ll x,ll y) {\r",
      "      return x+y;\r",
      "   }\r",
      "   void push(LTN *u) {\r",
      "      u->tv+=(u->lv)*((u->e)-(u->b)+1);\r",
      "      if(u->b<u->e) {\r",
      "         u->ls->lv+=u->lv;\r",
      "         u->rs->lv+=u->lv;\r",
      "      }\r",
      "      u->lv=0;\r",
      "   }\r",
      "   ll rnq(ll l,ll r) {return rnq(l,r,root);}\r",
      "   ll rnq(ll l,ll r,LTN *u) {\r",
      "      push(u);\r",
      "      if(r<u->b or u->e<l) return oobVal;\r",
      "      if(l<=u->b and u->e<=r) return u->tv;\r",
      "      return mrg(rnq(l,r,u->ls),rnq(l,r,u->rs));\r",
      "   }\r",
      "   ll upd(ll l,ll r,ll val){return upd(l,r,val,root);}\r",
      "   ll upd(ll l,ll r,ll val,LTN *u) {\r",
      "      push(u);\r",
      "      if(r<u->b or u->e<l) return u->tv;\r",
      "      if(l<=u->b and u->e<=r) { u->lv+=val; push(u); return u->tv;}\r",
      "      return u->tv=mrg(upd(l,r,val,u->ls),upd(l,r,val,u->rs));\r",
      "   }\r",
      "};"
    ]
  },
  "lct": {
    "prefix": "lct\r",
    "description": "",
    "body": [
      "\r",
      "struct Line {\r",
      "   ll m,b;\r",
      "   ll operator()(ll x){return m*x+b;}\r",
      "};\r",
      "struct LCNode {\r",
      "   Line val;\r",
      "   LCNode *ls=0,*rs=0;\r",
      "   LCNode(Line _val): val(_val){}\r",
      "\r",
      "   void upd(ll l,ll r,Line val) {\r",
      "      if(l+1==r) {\r",
      "         if(val(l)<this->val(l)) this->val=val;\r",
      "         return;\r",
      "      }\r",
      "      ll m=l+r>>1;\r",
      "      if(val.m<this->val.m) swap(val,this->val);\r",
      "      if(val(m)<this->val(m)) {\r",
      "         swap(val,this->val);\r",
      "         if(this->rs) this->rs->upd(m,r,val);\r",
      "         else this->rs=new LCNode(val);\r",
      "      } else {\r",
      "         if(this->ls) this->ls->upd(l,m,val);\r",
      "         else this->ls=new LCNode(val);\r",
      "      }\r",
      "      return;\r",
      "   }\r",
      "   ll rnq(ll l,ll r,ll x) {\r",
      "      if(l+1==r) return this->val(x);\r",
      "      ll m=l+r>>1;\r",
      "      if(x<m and (this->ls)) return min(this->val(x),this->ls->rnq(l,m,x));\r",
      "      if(this->rs) return min(this->val(x),this->rs->rnq(m,r,x));\r",
      "      return this->val(x);\r",
      "   }\r",
      "};"
    ]
  }
}
